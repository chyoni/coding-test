# 코딩 테스트 문제 풀이

- 매일 한 문제씩 풀면서, 어떤게 더 나은 코드인가?를 꾸준히 고민하는 개발자가 되어야겠다.
- 기술적인 질문과 답변이 생겼을때 항상 이곳에 기록하여 나의 지식 레퍼런스를 쌓아야겠다.

---

## 기술적 질문과 답변 정리

> **```String```, ```StringBuilder```, ```StringBuffer```의 차이가 무엇인가?**

```bash
[답변]
결론부터 말하면, 이 셋의 가장 큰 차이점은 '변경 가능성'과 '동기화 여부'이다.

[String]
String은 불변객체이다. 한 번 생성되면 그 값이 절대 변하지 않는다.
String에 + 연산을 하거나 값을 변경하면, 기존 객체가 변하는 게 아니라 새로운 String 객체를 생성하여 메모리에 할당한다.
장점: 캐싱, 보안, 그리고 멀티스레드 환경에서 안전하다.
단점: 문자열 수정이 잦은 경우, 계속해서 새로운 객체가 만들어지므로 GC가 할 일이 많아지고 성능이 저하된다.

[StringBuilder & StringBuffer]
이 두 클래스는 내부 Buffer에 문자열을 저장하며, 새로운 객체를 만들지 않고도 기존 값을 수정할 수 있다.(.append(), .delete(), ...)

StringBuilder
- 동기화를 지원하지 않는다.
- 특징: 멀티스레드 환경을 고려하지 않기 때문에 속도가 가장 빠르다.
- 사용 시점: 단일 스레드 환경이거나, 지역 변수로 문자열을 다룰 때 적합하다.

StringBuffer
- 동기화를 지원한다. (synchronized 키워드 사용)
- 특징: 여러 스레드가 동시에 같은 StringBuffer 객체에 접근해도 안전하게 설계되어 있다.
- 사용 시점: 멀티스레드 환경에서 안전하게 문자열을 공유하고 수정해야 할 때 사용한다.
```

| 구분     | String               | StringBuilder       | StringBuffer    |
|--------|----------------------|---------------------|-----------------|
| 변경 가능성 | 불변(Immutable)        | 가변(Mutable)         | 가변(Mutable)     |
| 동기화    | 해당 없음 (Thread-safe)  | 불충분 (Thread-unsafe) | 지원(Thread-safe) |
| 성능     | 낮음 (잦은 수정 시)         | 가장 빠름               | 보통 (동기화 오버헤드)   |
| 저장 위치  | String Constant pool | Heap                | Heap            |

---

> **Java의 Stack과 Heap 영역의 차이점에 대해 설명하고, 각 영역에 어떤 데이터가 저장되는가?**
```bash
[주요 차이점]
Stack: 메서드 실행 시 필요한 임시 메모리 공간이다. 각 스레드마다 별도로 생성된다.
Heap: JVM이 관리하는 공용 메모리 공간으로, 프로그램 실행 중 생성되는 모든 객체가 저장된다. 모든 스레드가 공유한다.

[저장되는 데이터]
Stack 영역:
- 메서드 호출 시 매개변수와 그 실제 값
- Heap 영역에 생성된 객체의 주소값
- 메서드가 호출되면서 콜 스택처럼 쌓이며, 종료되면 즉시 메모리에서 사라진다 (LIFO)

Heap 영역:
- 참조 타입: new 키워드로 생성된 객체, 배열, new String('Hello')와 같은 생성자를 사용한 문자열 객체
- 메서드가 끝나도 사라지지 않으며, 더 이상 참조하는 변수가 없을 때 GC에 의해 수거된다.
- String Constant Pool:
  - 문자열 리터럴이 보관되는 곳, 동일한 문자열을 다른곳에서 사용할 때 이곳에서 확인하여 같은 주소값을 재사용한다.
  - 만약 문자열 리터럴을 프로그램 실행중에 발견했다면, 이 곳에서 일단 같은 문자열 리터럴이 있는지 확인하고 있으면 해당 주소값을 재사용한다.
  - 확인했는데 없다면 이 곳에 새로 등록한다. 
  - 그래서 new String('Hello')와 같이 리터럴 여부와 상관없이 무조건 Heap 영역에 새로운 객체를 만드는 게 안좋은 행위라고 하는 것  

Stack은 크기가 정해져 있어 너무 깊은 재귀 호출이 일어나면 StackOverflowError가 발생하고, Heap은 가용 메모리를 넘어서면
OutOfMemoryError가 발생한다. 특히 Heap은 GC의 주 대상이 되기 때문에 효율적인 관리가 성능에 큰 영향을 미친다.
```

---

> **자바의 가비지 컬렉션(GC)이란 무엇이며, 어떤 원리로 동작하는지 설명해라.**
```bash
[정의]
Heap 메모리 영역에서 더 이상 사용되지 않는 객체(참조되지 않는 객체)를 찾아 메모리에서 자동으로 해제하는 프로세스이다.
이로 인해 개발자가 직접 메모리를 해제할 필요가 없게 해준다.

[핵심 동작 원리 (Stop-the-world & Mark and Sweep)]
- Stop-the-world: 
  - GC를 실행하기 위해, JVM이 애플리케이션 실행을 멈추는 작업이다. GC가 실행될 때는 GC 스레드를 제외한 모든 스레드가 멈춘다.
  - 현대의 자바는 사용자가 거의 느끼지 못할 만큼(수 밀리초 단위)빠르게 멈추도록 발전해 왔다.
  - 주기적인 작업이 아닌, 메모리가 부족할 때 일어나는 철저한 이벤트 기반 작업이다.
  - Minor GC의 경우 새로운 객체가 들어갈 공간(Young Generation)이 꽉 찼을 때 발생하고 보통 아주 빈번하고 매우 빠르게 끝난다.
  - Major GC의 경우 Old Generation 영역이 꽉 찼을 때 발생한다. 힙 전체를 뒤져야 하므로 시간이 오래 걸리고 위험하다.
- Mark and Sweep:
  - Mark: 스택의 모든 변수를 스캔하면서 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다. (사용 중인 객체 식별)
  - Sweep: 마킹되지 않은 객체들을 힙에서 제거한다.
 
[힙 영역의 구조(Young & Old Generation)]
대부분의 객체는 금방 소멸된다는 "Weak Generational Hypothesis" 가설에 따라 힙은 크게 두 구역으로 나뉜다.
- Young Generation: 새롭게 생성된 객체가 할당되는 곳. 여기서 발생하는 GC를 Minor GC라고 한다.
- Old Generation: Young 영역에서 살아남은 객체들이 이동하는 곳. 여기서 발생하는 GC를 Major GC(또는 Full GC)라고 한다.

[추가 포인트]
GC가 자주 발생하거나, Stop-the-world 시간이 길어지면 애플리케이션 성능이 저하된다. 따라서 불필요한 객체 생성을 줄이는 것이 중요하다.
```

---

> **인터페이스(Interface)와 추상 클래스(Abstract Class)의 차이점은 무엇이며, 각각 어떤 상황에 사용하는 것이 좋을까?**

| 구분    | Interface                             | Abstract Class       |
|-------|---------------------------------------|----------------------|
| 상속/구현 | 다중 상속 가능                              | 단일 상속만 가능            |
| 목적    | 객체의 행위에 대한 명세                         | 상속을 통한 코드 재사용, 확장    |
| 변수    | public static final (상수)만 가능          | 일반 멤버 변수(필드) 가질 수 있음 |
| 메서드   | 오직 추상 메서드 (Java 8+ default 메서드 기능 추가) | 일반 메서드 + 추상 메서드      |

```bash
[언제 무엇을 쓰는가?]
- 추상 클래스:
  - 관련된 클래스들 사이에 공통된 필드와 메서드가 많을 때 사용한다.
  - 예: Animal 클래스(속성: 나이, 이름 / 행위: 숨쉬기) -> 이를 상속받는 Dog, Cat

- 인터페이스:
  - 서로 다른 클래스들이라도 같은 기능을 수행해야 할 때 사용한다.
  - 주로 명세가 있고 이 명세를 어떤 기술을 가지고 구현하든 상관없이 클라이언트의 코드 변경을 없애기 위함이다.
```

---

> **HTTP와 HTTPS의 차이점은 무엇이며, HTTPS가 보안을 강화하는 방식에 대해 설명하라.**
```bash
[HTTP] 
텍스트 기반의 평문 데이터를 전송하는 프로토콜이다. 데이터가 암호화되지 않기 때문에 중간에 가로채기(스니핑)를 당하면
내용이 그대로 노출된다 (포트 번호: 80)

[HTTPS]
HTTP over SSL/TLS라고 하는데, HTTP에 SSL(Secure Socket Layer) 또는 TLS(Transport Layer Security) 프로토콜을 얹어
데이터를 암호화한 버전이다. (포트 번호: 443)

단순히 암호화만 하는 것이 아니라 다음 세 가지를 보장한다.
- 암호화: 제 3자가 데이터를 읽을 수 없게 만든다. (대칭키와 공개키 암호화 방식을 혼합해서 사용)
- 데이터 무결성: 전송 중에 데이터가 수정되거나 변조되지 않았음을 보장한다.
- 인증: 접속하려는 서버가 믿을 수 있는 진짜 서버임을 증명한다. (CA라는 신뢰할 수 있는 기관의 인증서 사용)

HTTPS 통신을 시작할 때, 클라이언트와 서버는 SSL Handshake 과정을 거친다. 이 과정에서 서버의 인증서를 확인하고,
데이터를 암호화하는 데 사용할 '대칭키'를 안전하게 교환한다. 실제 데이터 전송은 성능을 위해 대칭키 암호화를 사용하고,
그 대칭키를 공유할 때만 공개키 암호화를 사용한다.
```

---

> **데이터베이스 인덱스란 무엇이며, 왜 사용하는지 설명하라. 또한 인덱스를 설정할 때 고려해야 할 단점은 무엇인가?**
```bash
[인덱스의 정의와 목적]
정의: 추가적인 저장 공간을 활용해 데이터베이스 테이블의 검색 속도를 향상시키기 위한 색인이다.
목적: 데이터가 방대해질수록 테이블 전체를 읽는 Full Table Scan은 성능을 크게 저하시킨다. 인덱스를 사용하면 특정 조건에 맞는
데이터를 훨씬 빠르게 찾을 수 있다.

[동작 원리]
대부분의 관계형 데이터베이스는 B-Tree (Balanced Tree) 구조를 사용한다. 데이터를 정렬된 상태로 유지하며,
이진 탐색과 유사하게 탐색 범위를 절반씩 줄여나가기 때문에 매우 효율적이다.

[인덱스의 단점 및 주의사항]
인덱스가 많다고 무조건 좋은 것은 아니다.
- 저장 공간: 인덱스 자체를 저장하기 위한 별도의 메모리/디스크 공간이 필요하다.
- CUD 성능 저하: 데이터가 추가, 수정, 삭제될 때마다 인덱스도 함께 업데이트하고 정렬해야 하므로 쓰기 작업 성능이 떨어진다.
- 선택도: 데이터의 종류가 적은 컬럼(예: 성별 "남/여")에 인덱스를 걸면 효율이 낮다. 데이터가 중복되지 않고 유니크할수록 인덱스 효율이 극대화된다. 

인덱스는 "검색 성능"을 얻는 대신 "쓰기 성능"과 저장 공간을 희생하는 트레이드오프 관계에 있다. 따라서 실제 쿼리 사용 빈도와 데이터의 카디널리티를
분석하여 적절한 컬럼에 인덱스를 생성하는 것이 중요하다. 
```

---

> **자바의 synchronized 키워드와 volatile 키워드의 차이점에 대해 설명하라.**
```bash
[배경지식: CPU 캐시와 메모리]
현대 컴퓨터는 성능을 위해 메인 메모리(RAM)의 데이터를 CPU 캐시에 복사해서 사용한다. 이 과정에서 여러 스레드가 같은 변수를 다룰 때,
각 스레드가 보는 값이 서로 다른 가시성(Visibility) 문제나 원자성(Atomicity) 문제가 발생한다.

[volatile] = 가시성 보장
- 정의: 해당 변수를 읽거나 쓸 때, CPU 캐시가 아닌 메인 메모리에서 직접 읽고 쓰겠다고 명시하는 것
- 특징: 한 스레드가 쓴 값을 다른 스레드가 즉시 볼 수 있게 해준다. (캐시를 사용하지 않으니)
- 한계: 값의 일관성은 보장하나, 여러 단계의 연산이 일어나는 상황에서 원자성을 보장하지는 않는다. (동시성 이슈를 해결할 수 없음)

[synchronized] = 가시성 보장 + 원자성 보장
- 정의: 특정 코드 블록이나 메서드에 Lock을 걸어, 한 번에 하나의 스레드만 접근할 수 있도록 제어한다.
- 특징: 
  1. 가시성: Lock을 획득하고 해제할 때 메모리와 캐시를 동기화한다.
  2. 원자성: 블록 내부의 실행 단위를 하나로 묶어 다른 스레드가 중간에 끼어들지 못하게 한다.
- 한계: Lock을 걸고 푸는 비용 때문에 성능 오버헤드가 발생하며, Lock의 스코프는 JVM 프로세스 내부에서만 유효하기 때문에 
만약 여러 인스턴스를 사용하고 있다면 동시성 보장을 해주지 않는다.
```

---

> **트랜잭션의 격리 수준에는 어떤것들이 있으며, 각 수준에서 발생할 수 있는 문제점은 무엇인가?**
```bash
[트랜잭션 격리 수준 4단계]
격리 수준이 높아질수록 데이터 일관성은 엄격해지지만, 동시 처리 성능은 떨어지는 트레이드 오프 관계가 있다.
- [READ UNCOMMITTED (레벨 0)]: 커밋되지 않은 데이터도 다른 트랜잭션이 읽을 수 있음
- [READ COMMITTED (레벨 1)]: 커밋된 데이터만 읽을 수 있음 (대부분의 DB 기본 설정)
- [REPEATABLE READ (레벨 2)]: 트랜잭션 내에서 한 번 읽은 데이터를 반복해서 읽어도 항상 같은 결과가 나옴 (MySQL InnoDB 기본 설정)
- [SERIALIZABLE (레벨 3)]: 가장 엄격한 수준으로, 트랜잭션들이 순차적으로 실행되는 것처럼 동작함.

[발생할 수 있는 3가지 현상]
- Dirty Read: 다른 트랜잭션이 수정 중인(커밋 전)데이터를 읽는 현상 (레벨 0에서 발생)
- Non-Repeatable Read: 한 트랜잭션 내에서 같은 데이터를 두 번 조회했는데, 
그 사이 다른 트랜잭션이 값을 수정/삭제해서 결과가 달라지는 현상 (레벨 0, 1에서 발생)
- Phantom Read: 한 트랜잭션 내에서 일정 범위의 레코드를 두 번 조회했는데, 
그 사이 다른 트랜잭션이 데이터를 삽입해서 없던 데이터가 나타나는 현상 (레벨 0, 1, 2에서 발생)

실무에서는 보통 성능을 위해 READ COMMITTED나 REPEATABLE READ를 주로 사용한다. 특히 MySQL의 InnoDB는
Next-Key Lock을 사용하여 REPEATABLE READ에서도 Phantom Read를 어느 정도 방지해준다는 점이 특징이다.
아주 높은 정합성이 필요한 금전 거래 등에는 애플리케이션 레벨에서 락을 걸거나 SERIALIZABLE 고려가 필요하다.
```

---

> **데이터베이스에서 데드락(Deadlock)이 발생하는 원인은 무엇이며, 이를 방지하거나 해결하기 위한 전략은 무엇인가?"
```bash
[데드락 정의]
데드락은 두 개 이상의 트랜잭션이 서로가 가진 잠금(Lock)을 기다리며 무한히 대기하는 상태를 말한다.
쉽게 말해 "네가 가진 거 내놓으면 내가 진행할게"라고 서로 고집을 피우는 상황.

[발생 원인]
- 상호 배제(Mutual Exclusion): 한 번에 한 트랜잭션만 특정 자원(Row 등)을 점유할 수 있다.
- 점유 대기(Hold and Wait): 자원을 가진 상태에서 다른 자원을 추가로 요청함
- 비선점(No Preemption): 다른 트랜잭션의 자원을 강제로 뺏을 수 없음
- 순환 대기(Circular Wait): 트랜잭션 간의 자원 요구가 서로 꼬리를 물고 이어짐.

[방지 및 해결 전략]
- 접근 순서 통일: 모든 트랜잭션이 테이블이나 로우에 접근하는 순서를 동일하게 설계 (가장 현실적인 방안)
- 트랜잭션 범위 최소화: 트랜잭션의 실행 시간(메서드 내 비즈니스 로직 등)을 최대한 짧게 유지하여 Lock 점유 시간을 줄인다.
- 데드락 탐지기(Deadlock Detector): 대부분의 RDBMS는 내부적으로 데드락을 감지하여, 특정 트랜잭션을 강제로 롤백시키는 기능을 가지고 있다.
- 공정성: 너무 높은 격리 수준(SERIALIZABLE)보다는 적절한 수준을 선택하여 불필요한 Lock 범위를 줄인다.
```

---

> **해시 충돌(Hash Collision)이란 무엇이며, 이를 해결하기 위한 대표적인 방법 두 가지(Chaining, Open Addressing)에 대해 설명하라.**
```bash
[해시 충돌이란?]
해시 함수가 서로 다른 두 개의 입력값에 대해 동일한 해시값(인덱스)을 내놓는 상황을 말한다. 무한한 데이터를 유한한 해시 테이블 크기에
맞추려다 보니 발생하는 필연적 문제이다.

[해결 방법]

[Chaining]
- 아주 간단히 말해 같은 해시값을 가지는 경우 LinkedList로 구현하여 모두 저장하는 방식
- 특징: 해시 테이블 자체는 고정된 크기를 유지하며, 충돌이 나면 리스트 뒤에 계속 붙이기만 하면 되므로 구현도 간단

[Open Addressing (개방 주소법)]
- 충돌이 발생하면 비어있는 다른 버킷(주소)을 찾아 데이터를 저장하는 방식
- 탐사 방식:
  - Linear Probing: 바로 다음 칸이 비었는지 확인
  - Quadratic Probing: 제곱수만큼 떨어진 칸 확인
  - Double Hashing: 별도의 해시 함수를 한 번 더 사용해 건너뛸 간격 결정
- 특징: 모든 데이터를 테이블 안에 저장하므로 포인터 사용에 따른 오버헤드가 적지만, 데이터가 밀집되는 '클러스터링' 현상으로 성능이 떨어질 수 있다.

[추가 포인트]
데이터의 양이 적고 캐시 효율이 중요하다면 Open Addressing이 유리할 수 있지만, 데이터가 급격히 늘어날 가능성이 크고 삭제 작업이 빈번하다면
Chaining 방식이 더 유연하고 안정적인 성능을 보여준다.
```